// leetcode https://leetcode.com/problems/last-day-where-you-can-still-cross/?envType=daily-question&envId=2025-12-31


class Solution {
    // adding water will create separations between land cells. so its island. and what we want to find if top row and 
    // bottom row island are connected. should have thought about union sets.

    // 0 is land. 1 is water.
    public int latestDayToCross(int row, int col, int[][] cells) {
        DSU dsu = new DSU(row * col + 2);
        int[][] grid = new int[row][col];
        int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };

        for (int i = cells.length - 1; i >= 0; i--) {
            int r = cells[i][0] - 1;
            int c = cells[i][1] - 1;
            grid[r][c] = 1;
            // + 1 below because our DSU has one extra elements at top
            int index = r * col + c + 1; 

            for (int[] d : dirs) {
                int nr = r + d[0];
                int nc = c + d[1];
                int adjacentIndex = nr * col + nc + 1;
                // if adjacent index (nr,nc) are also land, then unionize it with our loop index
                if (nr >= 0 && nr < row && nc >= 0 && nc < col && grid[nr][nc] == 1)
                    dsu.union(index, adjacentIndex);
            }

            // if our loop index (land) is in the top row, unionize it with our virtual top node (0 of DSU)
            if (r == 0)
                dsu.union(0, index);

            // if our loop index (land) is in the bottom row, unionize it with our virtual bottom node (row*col+1 of DSU)
            if (r == row - 1)
                dsu.union(row * col + 1, index);

            // if top virtual node and bottom virtual node share same root, then it means they are connected. This 'i' 
            // if the first value we have hit while traversing 'cells' backwards ('last day where it is possible')
            if (dsu.find(0) == dsu.find(row * col + 1))
                return i;
        }

        return -1;
    }
}

// disjoint union set (a points to b, b points to c, c points to e, d points to e, e points to e. 
// This way abcde become a union with all their root as e
class DSU {
    int[] root;
    int[] size;

    DSU(int n) {
        // we take size of DSU as row*col + 2. Two extra nodes added.
        // 0th index is virtual top, n-1 is virtual bottom. 
        root = new int[n];
        size = new int[n];
        // 0 means land. We traverse 'cells' from last and add water cells and check if we can still reach top to bottom
        for (int i = 0; i < n; i++)
            root[i] = i;
        Arrays.fill(size, 1);
    }

    int find(int x) {
        if (root[x] != x)
            root[x] = find(root[x]);
        return root[x];
    }

    // smaller island goes to bigger island. Meaning abcd has root as c. mnopqr has root as p. So c has new root as p now.
    void union(int x, int y) {
        int rx = find(x);
        int ry = find(y);

        if (rx == ry)
            return;

        if (size[rx] > size[ry]) {
            int tmp = rx;
            rx = ry;
            ry = tmp;
        }

        root[rx] = ry;
        size[ry] += size[rx];
    }
}
