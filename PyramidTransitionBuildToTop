import java.util.*;

// leetcode https://leetcode.com/problems/pyramid-transition-matrix/description/?envType=daily-question&envId=2025-12-29
// youtube https://www.youtube.com/watch?v=dWlpBUZDQc0

public class PyramidTransitionBuildToTop {

    public int[][] topValuesForLeftAndRight;
    public Set<Long> seen;

    public static void main(String[] args)
    {
//        int[] a1 = {4,2,8};
        String s = "AAAA";
        String[] allowed = {"AAB","AAC","BCD","BBE","DEF"};

        String s2 = "BCD";
        String[] allowed2 = {"BCC","CDE","CEA","FFF"};

//        System.out.println(bestClosingTime(s));
        TestRandomCode fghj = new TestRandomCode();
        System.out.println(fghj.pyramidTransition(s, List.of(allowed)));
        System.out.println(fghj.pyramidTransition(s2, List.of(allowed2)));
    }

    public boolean pyramidTransition(String bottom, List<String> allowed) {
        // constraint: input letters are A to F
        topValuesForLeftAndRight = new int[6][6];
        // We are giving A-F as 0-5 value. If T[0][1] = 0010100 ,it means: AB -> {C, E}
        for (String a: allowed)
            topValuesForLeftAndRight[a.charAt(0) - 'A'][a.charAt(1) - 'A'] |= 1 << (a.charAt(2) - 'A');

        seen = new HashSet<>();

        //  x
        //  x x
        //  x x x
        //  x x x x
        // we fill the last row in pyramid A from 'bottom'
        int baseBlockSize = bottom.length();
        int[][] pyramid = new int[baseBlockSize][baseBlockSize];
        int temp = 0;
        for (char c: bottom.toCharArray())
            pyramid[baseBlockSize-1][temp++] = c - 'A';

        return solve(pyramid, 0, baseBlockSize-1, 0);
    }

    /**
     * row encoding explanation:
     * decimal is base 10 coded.
     * 347 =
     * intial is 0.
     * now comes 3. previous valuex10 = 0. 0+3x1=3.
     * now comes 4. previous valuex10 = 30. 30+4x1=34
     * now comes 7. previous valuex10 = 340. 340+7x1=347
     * Here we store complete row in base 7 encoded
     * Row = [C, A, F]
     * Indexes = [2, 0, 5]
     * 0x7 + 2x1 = 2
     * 2x7 + 0x1 = 14
     * 14x7 + 5x1 = 103
     * But [A, B] = [0, 1] and [B] = [1] both after encoding come as 1. So we use +1
     * Row = [C, A, F]
     * Indexes = [2, 0, 5]
     * 0x7 + 2x1 + 1 = 3
     * 3x7 + 0x1 + 1 = 22
     * 22x7 + 5x1 + 1 = 160
     */

    /**
     * backtracking + memoization
     * blockSize is number of elements in a row
     */
    public boolean solve(int[][] pyramid, long encodedRowValue, int blockSize, int columnIndexInTheRow) {
        // we have reached top row where row size is 1 and column index is 1
        if (blockSize == 1 && columnIndexInTheRow == 1) {
            return true;
        }
        else if (columnIndexInTheRow == blockSize)  // we have evaluated all column in this row
        {
            if (seen.contains(encodedRowValue))
            {
                // if this value would've worked, then we would have seen this value in some row, proceeded further and
                // reached top and returned true in question. so no point calculating again
                return false;
            }
            seen.add(encodedRowValue);
            // proceed to next row above. blockSize = current row, blockSize-1 = next row above
            return solve(pyramid, 0, blockSize-1, 0);
        }
        else
        {
            // T[0][1] = 0010100 ,it means: AB -> {C, E}
            int possibleValuesForTop =
                    topValuesForLeftAndRight[pyramid[blockSize][columnIndexInTheRow]][pyramid[blockSize][columnIndexInTheRow+1]];
            // we can have only 6 bits set (A to F)
            for (int b = 0; b < 6; ++b)
            {
                // 0010100 >> 2 = 0000101 &1 = 1, 2 = C
                // 0010100 >> 4 = 0000001 &1 = 1, 4 = E
                if (((possibleValuesForTop >> b) & 1) != 0) {
                    // blockSize = previous row, blockSize-1 = current row to fill new values
                    pyramid[blockSize - 1][columnIndexInTheRow] = b;
                    // solve for next index in row (columnIndexInTheRow + 1)
                    if (solve(pyramid, encodedRowValue * 7 + (b + 1), blockSize, columnIndexInTheRow + 1))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
    }

}
